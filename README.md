# ModularComponent

**ðŸž.with(ðŸ…).with(ðŸ§€) = ðŸ¥ª**

> Delightfully organized and deeply testable React Components

## What are Modular Components

Modular Components are React components built through a modular factory, allowing to
add functionality as needed as the component is built.

The modular factory approach is built on top of React hooks, and offers out-of-the-box
composition for building and stub injections for testing.

It offers best-in-class DX through strong typing and easy separation of concern, and is
infinitely extensible thanks to its built-in modular nature.

You can think of it as "higher-order hooks", without the awkward chaining of methods
thanks to the factory pattern.

## Installation

At it simplest, you will need the `@modular-component/core` package to get started with `ModularComponent`.

However, the core module alone does not bring any component capability - it needs plugins,
or extensions, to start shining âœ¨

We provide a sensible set of default capabilities through the `@modular-component/default` package.
It is highly recommended to install both for getting started.

```sh
yarn add @modular-component/core @modular-component/default
```

You can then build your component factory by combining the `modularFactory` export from
`@modular-component/core`, and the default set of stages exported as `withDefaultStages`
from `@modular-component/default`.

```tsx
import { modularFactory } from '@modular-component/core'
import { WithDefaultStages } from '@modular-component/default'

const ModularComponent = modularFactory.extend(WithDefaultStages).build()
```

You can then instantiate new components with the `ModularComponent` factory function:

```tsx
const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  .withDefaultProps({ someFlag: false })
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

## How it works

### The factory pipeline

#### Pipeline stages

The main concept behind the `ModularComponent` approach is the factory pipeline.

At its core, a `ModularComponent` is a set of ordered **stages**, each of which populates
a specific **argument** in a shared object, which gets passed from stage to stage.

The last stage (usually, but not necessarily, the **render stage**) has therefore access
to data computed by every previous stage in the pipeline.

This allows for instance to separate any stateful lifecycle computation in a dedicated
stage, and keep the render stage for its main purpose: laying down the markup through JSX.

Here is the "getting started" example, complete with comments explaining
the pipeline system:

```tsx
import { ModularComponent } from '@modular-component/core'

const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  // .withDefaultProps modifies the `props` argument to mark
  // provided props as NonNullable. Here, `someFlag` will be
  // a `boolean` for all further stages, instead of `boolean | undefined`
  // as it originally was
  .withDefaultProps({ someFlag: false })
  // .withLifecycle receives the modified props from .withDefaultProps
  // It then uses React hooks to construct our component's internal state
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  // Finally, .withRender receives both the up-to-date props and the new
  // lifecycle argument generated by the .withLifecycle stage
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

#### Stages modes

Each stage can be called multiple time, but the way subsequent calls to the
same stage are handled depends on its **mode**.

Stages can have one of two modes: **single** (default), or **multiple**.

- A **single**-mode stage can only be inserted once in a pipeline. Further calls
  to the same stage function will replace the implementation of the stage but keep its
  position in the pipeline.

  Because of this, it's important that the provided argument honors the contract
  set up by the very first call, otherwise it could break stages depending on it.

  When using TypeScript, this is enforced internally, and a subsequent call to an already
  added stages will be narrowed to force honoring previous contracts.

- A **multiple**-mode stage on the other hand can appear in various places in the pipeline.

  Further calls to the stage function will simply add new stages to the pipeline, modifying the
  generated value only for further stages down the pipeline.

  Since calls are never modified, further calls can completely change the value of the field
  without any impact on previous stages. For the same reason, the TypeScript definition is not
  restricted in any way.

The reason for the **single** mode being default is to help re-usability: for instance, you can
extend an existing component by replacing its lifecycle but keeping the same render, of vice-versa.

This also makes `ModularComponent`s easy to test: stages can be tested in isolation from one another.

### The extension system

`ModularComponent` aims to be a toolkit, and as such, it needs to be as agnostic as possible
of the application context. For this reason, the core factory only implements a single stage: `withRender`,
which is in fact a simple, traditional React function component.

Capabilities can then be added on a per-application basis, to construct a pipeline that
makes sense for a specific application context: adding a stage for connecting to a global
store, or for handling internationalization...

Such capabilities are added through **extensions**. Extensions are configuration objects
detailing a new stage method to add to the pipeline.

> **Understanding stages**
>
> Each stage of a pipeline receives _exactly one argument_, that can take two forms:
>
> - A primitive value, array or object (_but **not a function**_) to inject as argument
>   for further stages,
> - A hook receiving the current set of arguments and computing the value to add.
>
> If the value to inject should be a function, then it is mandatory to use the hook parameter
> to wrap the function, otherwise the factory wouldn't know if it should execute the function
> or pass it down as-is:
>
> ```tsx
> // This will fail, the factory will execute the function thinking it's a hook!
> ModularComponent().withSomeFunction(myFunction)
>
> // This will work, the factory will execute the anonymous function as a hook,
> // and pass the returned function as argument for further stages
> ModularComponent().withSomeFunction(() => myFunction)
> ```
>
> When executed, each stage modifies _exactly one argument_ in the shared arguments map.

#### Setting a name and a target argument

In order to add a new stage, we need to provide at the very least:

- The name of the method to add to the factory (`withLifecycle`, `withDefaultProps`...)
- The name of the argument modified by the stage (`lifecycle`, `props`...)

Extensions are written as a map of method name to method configuration. For instance, the `withLifecycle`
definition looks something like this:

```tsx
export const WithLifecycle = {
  withLifecycle: {
    field: 'lifecycle',
  },
} as const
```

You can add as many stage methods as you want. Different stage methods can also impact
the same field if needed, for some advanced cases.

#### Type-safe definition: the `createMethodRecord` helper

To ensure the configuration you produce is valid, you can wrap it in `createMethodRecord` exported
by `@modular-component/core`:

```tsx
import { createMethodRecord } from '@modular-component/core'

export const WithLifecycle = createMethodRecord({
  withLifecycle: {
    field: 'lifecycle',
  },
} as const)
```

Notice the `as const` statement, making sure TypeScript narrows all
types as much as possible. It is of paramount importance to always add this statement
to ensure type inference works correctly. Otherwise, the `field` parameter
could be inferred as `string`, polluting the complete arguments map.

If you provide a misconfigured method, the `createMethodRecord` function
will reject the argument, letting you know right away.

#### Transforming the argument before committing it to the map

This simple definition of a method is enough for mapping the result of a hook to an argument,
or to map an arbitrary primitive, object or array to the argument, but it might not
be sufficient for other cases. For instance, the `withDefaultProps` stage needs to take
into account existing props, without needing the user to pass them down manually each time.

For this purpose, a method can also receive a `transform` configuration parameter, detailing
how to generate the final value that will be added to the arguments map.

The `transform` function receives two parameters: the current arguments map received from
previous stages, and the value passed down to the stage by the user. It then returns the
transformed value to add to the argument map.

For instance, here is a simplified definition for `withDefaultProps`:

```tsx
export const WithDefaultProps = createMethodRecord({
  withDefaultProps: {
    field: 'props',
    transform: (args, defaultProps) => ({
      ...defaultProps,
      ...args.props,
    }),
  },
} as const)
```

The stage is configured to modify the `props` field, and its custom transform function
merges the provided default props.

However, there is a mistake in the above transform function: the second parameter
is the raw value passed down by the user: it can therefore be a function. When writing
a transform function, you need to account for this case manually. Here is a correct
implementation of the above transform:

```tsx
export const WithDefaultProps = createMethodRecord({
  withDefaultProps: {
    field: 'props',
    transform: (args, useDefaultProps) => ({
      ...(typeof useDefaultProps === 'function'
        ? useDefaultProps(args)
        : useDefaultProps),
      ...args.props,
    }),
  },
} as const)
```

Note how we also renamed the parameter to `useDefaultProps`: as this can be a hook, we
need to name it accordingly to not break the rule of hooks here.

While this might seem cumbersome, it offers a great flexibility for writing extensions:

- It gives the opportunity to manipulate the args passed down to the hook, if needed,
- It allows delaying or the call to the function to the transform function, which can
  for instance decide not to call it at all based on previous arguments.

#### Telling TypeScript about a value transformation

Sometimes, the transformation that we want to apply on a value might change its type
from the one passed as parameter. Unfortunately, as of TypeScript 4.8, there isn't
a way still to use "generic generic types". It is therefore not possible, as far as we can tell,
to retrieve the type of the `transform` configuration and use it to infer the final type
of the argument.

The workaround implemented for now is an exposed interface, `ModularStageTransform`, that
takes a generic parameter and contains a map of transformed type. An extension package
can overload this interface to add the correct transform for the provided stage.

In order to avoid clashes between multiple extensions providing a similar
stage function name, the transform map uses _symbols_ as its key to ensure
uniqueness. The symbol must be passed to the corresponding stage function definition.

For instance, let's imagine a `withArray` stage that wraps the passed value in an array:

```tsx
const arraySymbol = Symbol()

export const WithArray = createMethodRecord({
  withArray: {
    field: 'array',
    symbol: arraySymbol,
    transform: (args, useArray) => [
      typeof useArray === 'function' ? useArray(args) : useArray,
    ],
  },
} as const)
```

Using it as-is, `ModularComponent().withArray('hello world')` would incorrectly infer the
type of the `array` argument as `string`. We can help TypeScript along by extending the `ModularStageTransform`
type:

```tsx
declare module '@modular-component/core' {
  export interface ModularStageTransform<T> {
    [arraySymbol]: [T]
  }
}
```

With this, TypeScript will correctly infer the type of our example to `[string]`!

#### Restricting the type of the passed value

Specifically for TypeScript users, stage method configuration allows defining a type
that the passed value should match to be considered valid. This information will be
surfaced to the user, marking the stage call as incorrect if the value type do not match
the expected restriction.

For instance, we might want to restrict values passed to the `withDefaultProps` stage to
only accept objects, as any other value do not make sense here.

This is done through the `restrict` property:

```tsx
export const WithDefaultProps = createMethodRecord({
  withDefaultProps: {
    field: 'props',
    transform: (args, useDefaultProps) => ({
      ...(typeof useDefaultProps === 'function'
        ? useDefaultProps(args)
        : useDefaultProps),
      ...args.props,
    }),
    restrict: {} as Record<string, unknown>,
  },
} as const)
```

Note that the value passed to the `restrict` configuration is not important, it will
never be used internally. What matters is _its type,_ that we force through the `as`
statement here.

#### Enabling multiple mode on a stage

Sometimes, it does not make sense to reuse/modify the previous stage when calling the
same stage multiple times. Sometimes on the contrary, we want a stage to run multiple times
at various places in our pipeline.

Let's take for example a `withDebug` stage that logs the current args to the console,
and optionally takes an empty function as parameter to serve as breakpoint:

```tsx
export const WithDebug = createMethodRecord({
  field: 'debug',
  multiple: true,
  restrict: undefined,
  transform: (args, useDebug) => {
    if (typeof useDebug === 'function') {
      useDebug(args)
    } else {
      console.log(args)
    }
  },
})
```

All that was needed here was adding the `multiple: true` flag to our configuration.

From there on, calling `withDebug()` multiple time on the same `ModularComponent`
will log the arguments gathered up until each debug stage.

> **Side note: `restrict: undefined`**
>
> Whenever `restrict: undefined` is used on a stage method, the type
> definition will allow users to omit the argument completely, making `useDebug()`
> a valid call instead of requiring `useDebug(undefined)`. Useful for
> stages that return a constant value or only execute side-effects!

## Other methods

Atop of the factory stages configured through extensions, `ModularComponent`s
also expose two more methods:

- `asHook`: extract the stages as a custom hook, returning the map of arguments.
  This is used internally when calling the generated component, but can also be
  useful in other situations like tests, or the need to generate a shared hook
  consuming application context, such as a global store for which a stage exists.

  It optionally takes a string parameter allowing to extract a specific argument.

- `atStage`: rewinds a factory all the way up to a specific stage
  (in case on multiple-mode stages, the last occurrence is used), and return the
  a new `ModularComponent` with the remaining stages.
  Useful for instance to test in isolation the first few stages of a component.

Combining those two methods can be very powerful in testing scenarios. For instance,
one can extract the lifecycle hook of a component by chaining them:

```tsx
const useLifecycle = MyComponent.atStage('withLifecycle').asHook('lifecycle')
```

## Official extensions

### `@modular-component/default`

Set of sensible defaults for using `ModularComponent`. Provides two stages:
`withLifecycle` for adding a lifecycle hook, and `WithDefaultProps` for
providing default values for props.

It's also possible to import each of them individually through `@modular-component/with-lifecycle`
and `@modular-component/with-default-props` respectively.

### `@modular-component/with-components`

Provides a `withComponents` stage that fills the `components` argument with
a map of React components. Useful when running tests in an environment that
does not allow module mocking: sub-components can be stubbed in tests by
calling the stage again to replace their implementations.

### `@modular-component/with-conditional-render`

Provides three stages that allow conditional rendering in `ModularComponent`s:

- `withCondition` will set a `condition` argument to either `true` or `false`, based
  on current arguments,
- `withConditionalFallback` takes a `FunctionComponent` as parameter, and
  renders it when the `condition` argument is set to `false`,
- `withConditionalRender` also takes a `FunctionComponent` as parameter, and
  renders it when the `condition` argument is _not_ set to `false`.

`withCondition` and `withConditionalFallback` are multiple, so it's possible
to chain multiple conditions with a different fallback for each. Subsequent calls
to `withCondition` will take into account preceding conditions, so that `withConditionalRender`
is only called when all conditions return `true`.
